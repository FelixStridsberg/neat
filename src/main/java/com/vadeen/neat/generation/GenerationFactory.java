package com.vadeen.neat.generation;

import com.vadeen.neat.genome.Genome;
import com.vadeen.neat.genome.GenomeFactory;
import com.vadeen.neat.species.Species;
import com.vadeen.neat.species.SpeciesFactory;

import java.util.*;

public class GenerationFactory {
    /**
     * Factory for creating the genomes.
     */
    private GenomeFactory genomeFactory;

    /**
     * Factory for creating the species.
     */
    private SpeciesFactory speciesFactory;

    /**
     * Size of population.
     */
    private int populationSize = 150;

    /**
     * Refocus species count. Only the best n species will be evolved during a refocus.
     */
    private int refocusSpeciesCount = 2;

    /**
     * Which proportion of genomes generated by mutation only. The rest is crossed.
     */
    private float offspringByMutation = 0.25f;

    /**
     * Max amount of species in relation to population size.
     */
    private float maxSpeciesProportion = 0.3f;


    public GenerationFactory(GenomeFactory genomeFactory, SpeciesFactory speciesFactory) {
        this.genomeFactory = genomeFactory;
        this.speciesFactory = speciesFactory;
    }

    /**
     * Create next generation from an existing generation.
     */
    public Generation next(Generation old) {
        // Species we transfer from old generation.
        Map<Species, Float> speciesProportions = getSpeciesProportions(old);

        // If no species got any proportions, we generate a generation by full mutation instead.
        if (speciesProportions.isEmpty()) {
            return fullMutation(old);
        }

        return breedAndMutateProportionally(old, speciesProportions);
    }

        /**
     * Creates a new generation containing only the best `refocusSpeciesCount` species.
     */
    public Generation refocus(Generation generation) {
        // Best genome might not be in the top species so we have to make sure it's transferred to not loose progress.
        Genome bestGenome = generation.getBestGenome();

        // If there is not enough species. We can't do much to refocus.
        if (generation.getSpecies().size() <= refocusSpeciesCount)
            return generation;

        // Get sorted species, best fitness first.
        List<Species> species = new ArrayList<>(generation.getSpecies());
        species.sort(Comparator.reverseOrder());

        List<Species> refocusSpecies = new ArrayList<>();
        for (int i = 0; i < refocusSpeciesCount; i++) {
            Species s = species.get(i);
            refocusSpecies.add(s);

            if (s.getBestGenome() == bestGenome)
                bestGenome = null;
        }

        // If best genome was not transferred by species, we add it.
        if (bestGenome != null)
            refocusSpecies.add(speciesFactory.createSpecies(bestGenome));

        return new Generation(refocusSpecies);
    }

    public GenomeFactory getGenomeFactory() {
        return genomeFactory;
    }

    public void setGenomeFactory(GenomeFactory genomeFactory) {
        this.genomeFactory = genomeFactory;
    }

    public SpeciesFactory getSpeciesFactory() {
        return speciesFactory;
    }

    public void setSpeciesFactory(SpeciesFactory speciesFactory) {
        this.speciesFactory = speciesFactory;
    }

    public int getPopulationSize() {
        return populationSize;
    }

    public void setPopulationSize(int populationSize) {
        this.populationSize = populationSize;
    }

    public int getRefocusSpeciesCount() {
        return refocusSpeciesCount;
    }

    public void setRefocusSpeciesCount(int refocusSpeciesCount) {
        this.refocusSpeciesCount = refocusSpeciesCount;
    }

    public float getOffspringByMutation() {
        return offspringByMutation;
    }

    public void setOffspringByMutation(float offspringByMutation) {
        this.offspringByMutation = offspringByMutation;
    }

    public float getMaxSpeciesProportion() {
        return maxSpeciesProportion;
    }

    public void setMaxSpeciesProportion(float maxSpeciesProportion) {
        this.maxSpeciesProportion = maxSpeciesProportion;
    }

    /**
     * Create new generation by breeding and mutating according to setting.
     * Better species breed and mutate more.
     */
    private Generation breedAndMutateProportionally(Generation old, Map<Species, Float> speciesProportions) {
        // Keep track of best genome so we know it's transferred untouched.
        Genome best = old.getBestGenome();

        // New crossed and mutated genomes not sorted in a species yet.
        List<Genome> genomes = new ArrayList<>();

        // Species transferred from previous generation.
        List<Species> species = new ArrayList<>();

        // Generate new genomes by breeding.
        float offspringByBreeding = 1.0f - offspringByMutation;
        for (Map.Entry<Species, Float> e : speciesProportions.entrySet()) {
            Species s = e.getKey();
            float proportion = e.getValue();
            int populationSize = (int)(this.populationSize * offspringByBreeding * proportion);

            // Always transfer best genome.
            if (populationSize == 0 && s.getBestGenome() == best)
                populationSize = 1;

            if (populationSize == 0)
                continue;

            // Copy old species to new one. Add best genome as reference.
            species.add(speciesFactory.copy(s, Genome.copy(s.getBestGenome())));

            for (int i = 0; i < populationSize - 1; i++) {
                genomes.add(generateGenomeFromSpecies(s));
            }
        }

        // Generate new genomes by mutation.
        for (Species s : old.getSpecies()) {
            float proportion = speciesProportions.get(s);
            int populationSize = (int)(this.populationSize * offspringByMutation * proportion);

            for (int i = 0; i < populationSize; i++) {
                genomes.add(genomeFactory.copyMutate(s));
            }
        }

        // Fill up the rest by cross species breeding.
        while (species.size() + genomes.size() < populationSize) {
            Genome child = genomeFactory.breed(species);
            if (child != null)
                genomes.add(child);
        }

        // Sort all unsorted genomes into species to get the next population.
        List<Species> finalPopulation = speciesFactory.generate(species, genomes);

        return new Generation(finalPopulation);
    }

    /**
     * Creates a new generation by mutating every genome, except the best one.
     */
    private Generation fullMutation(Generation old) {
        Genome best = old.getBestGenome();

        List<Genome> genomes = new ArrayList<>();
        for (Species s : old.getSpecies()) {
            for (Genome g : s.getGenomes()) {
                if (g == best)
                    genomes.add(Genome.copy(g));
                else
                    genomes.add(genomeFactory.copyMutate(g));
            }
        }

        return new Generation(speciesFactory.generate(genomes));
    }

    /**
     * @return Map of species and proportion by size.
     */
    private Map<Species, Float> getSpeciesProportions(Generation old) {
        ArrayList<Species> oldSpecies = new ArrayList<>(old.getSpecies());
        oldSpecies.sort(Comparator.reverseOrder());

        Map<Species, Float> result = new HashMap<>();
        if (oldSpecies.size() == 1) {
            result.put(oldSpecies.get(0), 1.0f);
            return result;
        }

        Genome best = old.getBestGenome();

        float totalFitness = 0.0f;
        for (Species s : oldSpecies) {
            totalFitness += s.getFitness();

            // TODO temporary, double fitness for species with best genome to make it populate more.
            if (s.getBestGenome() == best)
                totalFitness += s.getFitness();
        }

        for (Species s : oldSpecies) {
            if (totalFitness == 0)
                break;

            float fitness = s.getFitness();

            // TODO temporary, double fitness for species with best genome to make it populate more.
            if (s.getBestGenome() == best)
                fitness += s.getFitness();

            float proportion = fitness/totalFitness;
            result.put(s, proportion);
        }

        // TODO maxSpecies = maxSpeciesProportion*populationSize

        return result;
    }

    /**
     * Tries to breed a genome in a species. If failing to many times, creates a new genome by mutation.
     */
    private Genome generateGenomeFromSpecies(Species s) {
        // Try to breed 5 times
        for (int t = 0; t < 5; t++) {
            Genome child = genomeFactory.breed(s);

            if (child != null)
                return child;
        }

        // Breeding failed. Create by mutation.
        return genomeFactory.copyMutate(s);
    }
}
